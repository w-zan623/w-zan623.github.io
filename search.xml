<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【notes】docker学习笔记5-dockerfile]]></title>
    <url>%2F2019%2F08%2F08%2Fdocker-5%2F</url>
    <content type="text"><![CDATA[dockerfile指令指令格式注释： # Comment指令： INSTRUCTION argument FROM FROM &lt;image&gt; FROM &lt;image&gt;:&lt;tag&gt; 必须已经存在的镜像，也就是基础镜像 必须是第一条非注释指令 MAINTAINER MAINTAINER &lt;name&gt; 指定镜像的作者信息，包含镜像的所有者和练习方式 RUN构建构成运行的 RUN &lt;command&gt; (shell模式) /bin/sh -c command RUN [“executable”, “param1”, “param2”] (exec模式) RUN[“/bin/bash”, “-c”, “echo hello”] EXPOSE EXPOSE &lt;port&gt; [&lt;port&gt;…] 指定运行该镜像的容器使用的端口，但只是告诉docker会使用特定的端口号，出于安全考虑不会自动打开，在容器运行时仍需要手动指定端口映射。CMD ENTERYPOINT 指定容器启动时运行的命令 CMD [“executable”, “param1”, “param2”] (exec模式) CMD command param1 param2 (shell模式) CMD [“params1”, “params2”] (作为ENTRYPOINT指令的默认参数) 在docker run时如果指定命令的话dockerfile里的cmd命令会被覆盖掉。 ENTRYPOINT [“executable”, “param1”, “param2”] (exec模式) ENTRYPOINT command param1 param2 (shell模式) 默认不会被覆盖，如果需要覆盖需要指定docker run –entrypoint 覆盖 ADD COPY VOLUME设置镜像的目录和文件 WORKDIR ENV USER构建及容器运行时的环境设置 ONBUILD]]></content>
      <categories>
        <category>笔记</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【notes】docker学习笔记4-docker客户端与守护进程]]></title>
    <url>%2F2019%2F08%2F07%2Fdocker-4%2F</url>
    <content type="text"><![CDATA[docker的C/S模式 客户端与守护进程通信的接口 命令行接口 remote API： RESTful风格API STDIN STDOUT STDERR 语言参考：https://docs.docker.com/reference/api/docker_remote_api 连接方式 unix:///var/run/docker.sock 默认方式 tcp://host:port fd://socketfd 利用socket进行通信 查看正在运行的守护进程 1ps -ef | grep docker 连接socket进行通信 12nc -U /var/run/docker.sockGET /info HTTP/1.1 以上都是在本地的访问，docker也支持远程访问。 docker守护进程的配置和操作 查看守护进程 12ps -ef | grep dockersudo status docker 守护进程的启动、停止和重启 123sudo service docker startsudo service docker stopsudo service docker restart docker的启动选项 1docker -d [OPTIONS] #所以守护形式运行 运行相关: -D, –debug = false -e, –exec-driver = “native” -g, –graph = “/var/lib/docker” –icc = true -l, –log-level = “info” –label = [] -p, –pidfile = “/var/run/docker.pid” docker服务器连接相关： -G, –group = “docker” -H, –host = [] –tls = false –tlscacert = “/home/sven/.docker/ca.pem” –tlscert = “/home/sven/.docker/cert.pem” –tlskey = “/home/sven/.docker/key.pem” –tlsverify = false RemotAPI相关： –api-enable-cors = false Registry相关： –insecure-registry = [] –registry-mirror = [] 网络设置相关： -b, –bridge = “” –bip = “” –fixed-cidr = “” –fixed-cidr-v6 = “” –dns = [] –dns-search = [] –ip = 0.0.0.0 –ip-forward = true –ip-masq = true –iptables = true –ipv6 = false –mtu = 0 启动配置文件 /etc/default/docker 注：ubuntu 16.04及以上版本使用： 修改/lib/systemd/system/docker.service中的ExecStart 加载配置： 123systemctl daemon-reloadservice docker restartdocker info docker的远程访问 第二台安装docker的服务器 保证Client API与Server API版本一致 修改docker守护进程启动选项 修改服务器端配置 -H tcp://host:post unix:///path/to/socket fd://* or fd//socketfd 守护进程默认配置： -H unix:///var/run/docker.sock 注：我的默认的是 fd:// 改为 tcp: tcp://0.0.0.0:2375 1curl http://ip:2375/info 修改客户端配置 -H tcp://host:post unix:///path/to/socket fd://* or fd//socketfd 默认配置： -H unix:///var/run/docker.sock docker -H tcp//ip:2375 # 太麻烦 export DOCKET_HOST=”tcp://ip:2357” # 使用环境变量 export DOCKET_HOST=”tcp://ip:2357” # 使用本地 怎样在设置了远程连接的服务器也支持本机连接？答：给-H再增加一个方式，-H可以设置多个值。]]></content>
      <categories>
        <category>笔记</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【notes】docker学习笔记3-docker镜像]]></title>
    <url>%2F2019%2F08%2F06%2Fdocker-3%2F</url>
    <content type="text"><![CDATA[查看和删除镜像 镜像的存储位置：/var/lib/docker 列出镜像1docker images [OPSIONS] [REPOSITORY] -a, –all = false # 显示所有镜像，默认并不显示中间层镜像（没有标签名的镜像） -f, –filter = [] # 过滤条件 –no-trunc = false # 不使用截断的形式来显示数据(默认使用截断显示EID，比文件名短) -q, –quiet = false # 只显示EID 镜像标签和仓库 镜像仓库 区分： REPOSITORY 仓库 REGISTRY 仓库 REGISTRY里会有很多REPOSITORY仓库，每个REPOSITORY里会有一个个独立的镜像。 标签 TAG 镜像的名字 = 镜像仓库名 : 镜像标签 –对应–&gt; 镜像ID ubuntu:latest, ubuntu:14.04, ….. 如果没有指定标签，默认为latest。 同一仓库的不同标签可以对应同一镜像ID，也就是说可以根据需求给同一镜像文件打上不同的标签。 没有标签名的镜像称作中间层镜像。 查看镜像1docker inspect [OPTIONS] CONTIANER|IMAGE [CONTAINER|IMAGE...] -f, –format=”” 删除镜像1docker rmi [OPTIONS] IMAGE [IMAGE...] -f, –force = false 强制删除 –no-prune = false 不删除未打标签的父镜像 对应多个标签的镜像文件可以直接用ID选定所有标签 1docker rmi ID 获取和推送镜像查找镜像 Docker Hub https://registry.hub.docker.com docker search 1docker search [OPTIONS] TERM –automated = false –no-trunc = false -s, stars = 0 只显示最少多少stars的 最多返回25个结果 拉取镜像1docker pull [OPTIONS] NAME [:TAG] -a, –all-tags = false 下载仓库中所有被标记的镜像 推送镜像1docker push username/IMAGE 构建镜像 保存对容器的修改，并再次使用 自定义镜像的能力 以软件的形式打包并分发服务及其运行环境 docker commit通过容器构建 1docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] -a, –author=”” Author e.g., “John Hannibal Smith hannibal@a-team.com“ -m, –message=”” 记录构建的信息 -p, –pause = true 不暂停容器的运行 docker build通过Dockerfile文件构建 dockerfile: #First DockerfileFROM ubuntu:14.04MAINTAINER dormancypress “dormancypress@outlook.comRUN apt-get updateRUN apt-get install -y nginxEXPOSE 80 1docker build [OPTIONS] PATH|URL|- –force-rm = false –no-cache = false –pull=false -q,–quiet = false –rm = true -t, –tag=””]]></content>
      <categories>
        <category>笔记</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【notes】docker学习笔记2-docker容器]]></title>
    <url>%2F2019%2F08%2F06%2Fdocker-2%2F</url>
    <content type="text"><![CDATA[容器的基本操作启动容器 仅一次命令 1docker run IMAGE [COMMAND] [ARG] 启动交互式容器 1docker run -i -t IMAGE /bin/bash -i –interactive=ture | false 默认是false，为容器始终打开标准输入-t –tty=true | false 默认是false，分配一个终端 自定义容器名字 1docker run --name=自定义名 -i -t IMAGE /bin/bash 重新启动已建立的容器docker start [-i] 容器名 查看容器 不加参数是正在运行的容器，-a是所有容器，-l是最新创建的一个容器。 1docker ps [-a] [-l] 查看容器参数 1docker inspect [ID] or [name] 删除容器1docker rm 容器名 守护式容器什么是守护式容器： 能够长期运行 没有交互式会话 以守护形式运行容器：12docker run -i -t IMAGE /bin/bashCtrl + P Ctrl + Q 附加到运行中的容器1docker attach 容器名 启动守护式容器1docker run -d 镜像名 [COMMAND] [ARG...] 得知容器运行情况1docker logs [-f] [-t] [--tail] 容器名 -f –follows=true | false 默认为false 一直跟踪日志变化并返回结果-t –timestamps=true | false 默认为false 结果加上时间戳–tail= “all” 多少数量的日志 查看运行中容器进程1docker top 容器名 在运行中的容器内启动新进程1docker exec [-d] [-i] [-t] 容器名 [COMMAND] [ARG...] 停止守护式容器 发送指令等待停止 1docker stop 容器名 直接停止容器 1docker kill 容器名 ###在容器中部署静态网站 设置容器的端口映射run [-P] -P , –publish-all = true | false 默认为false 为容器暴露的所有端口设置映射 1docker run -P -t -i ubuntu /bin/bash -p , 指定端口 容器端口 1docker run -p 80 -i -t ubuntu /bin/bash 宿主机端口:容器端口 1docker run -p 8080:80 -i -t ubuntu /bin/bash ip::容器端口 1docker run -p 0.0.0.0:80 -i -t ubuntu /bin/bash ip:宿主机端口:容器端口 1docker run -p 0.0.0.0:8080:80 -i -t ubuntu /bin/bash Nginx部署 创建映射80端口的交互式容器 1docker run -p 80 --name web -it ubuntu /bin/bash 安装Nginx 安装文本编辑器vim 1234apt-get updateapt-get upgradeapt-get install nginx -yapt-get install vim -y 创建静态页面 12mkdir -p /var/www/htmlvim index.html 修改Nginx配置文件 1vim /etc/nginx/sites-enabled/default 运行Nginx 123nginxps -efCtrl P Ctrl Q 验证网站访问 1234docker port web # 查看端口映射情况docker top web # 查看进程运行情况docker inspect web #查看ipcurl http://172.17.0.2]]></content>
      <categories>
        <category>笔记</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【notes】docker学习笔记1-docker基本组成]]></title>
    <url>%2F2019%2F08%2F06%2Fdocker-1%2F</url>
    <content type="text"><![CDATA[Docker的基本组成 Docker Client 客户端 Docker Daemon 守护进程 Docker Image 镜像 Docker Container 容器 Docker Registry 仓库 Docker客户端/守护进程 C/S架构 docker客户端对服务器的访问： 本地/远程 docker客户端向发送给守护进程请求，守护进程的执行结果还会传回给客户端。 Docker Image镜像 构建和打包阶段。 容器的基石，相当于保存了容器运行需要的源代码。 层叠的层叠文件系统。 bootfs（引导文件系统）-&gt; rootfs(Ubuntu) -&gt; add emacs -&gt; add Apache 联合加载（union mount）:一次加载多个文件系统（add Apache，add emacs），将所有文件系统叠加在一切。镜像可以叠加在一起，位于底部的成为基础镜像（rootfs），add emacs（副镜像）。 Docker Container容器 通过镜像启动。 启动执行阶段。 配置数据和镜像层（bootfs -&gt; ······ -&gt; add emacs) -&gt; 可写层。 写时复制：docker出现变化时都会应用到可写层，先从只读镜像层复制到可写层然后只读层的文件被隐藏。 Docker Registry仓库 保存docker镜像。 分为公有和私有。公有：Docker Hub 图示结构Docker: Docker Image: Docker Container: docker基本指令 查找镜像 1docker search tutorial 下载镜像 1docker pull learn/tutorial 启动一个容器，使用echo命令输出hello world 1docker run learn/tutorial echo 'hello world' 启动一个容器下载ping 1docker run learn/tutorial apt-get install -y ping 查看有哪些容器 1docker ps -l 提交容器，即创建一个新的镜像 1docker commit [docker ID] learn/ping 用新镜像建立一个容器 1docker run learn/ping ping www.baidu.com 查看容器信息 1docker inspect [docker ID] 查看有哪些镜像 1docker image 将镜像保存到docker hub上 1docker push /learn/ping Docker容器相关技术简介Docker依赖的Linux内核特性 Namespaces 命名空间 提供了系统资源的隔离，for轻量级虚拟化服务 五种命名空间： PID 进程隔离 NET 管理网络接口 IPC 管理跨进程通信的访问 MNT 管理挂载点 UTS 隔离内核和版本标识 Control groups 控制组 资源限制（内存上限等） 优先级设定（设定哪些进程组使用哪些资源） 资源计量 资源控制（挂起恢复） Docker容器的能力 文件系统隔离：每个容器都有自己的root文件系统 进程隔离： 每个容器都运行在自己的进程环境中 网络隔离： 容器间的虚拟网络接口和IP地址都是分开的 资源隔离和分组：使用cgroups将CPU和内存之类的资源独立分配给每个Docker容器]]></content>
      <categories>
        <category>笔记</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【notes】Git笔记-1]]></title>
    <url>%2F2019%2F08%2F05%2Fgit-1%2F</url>
    <content type="text"><![CDATA[Git工作流程 克隆Git资源作为工作目录。 在克隆的资源上修改文件。 如果其他人修改，你也可以修改资源。 在提交前查看修改。 提交修改 提交后后悔的话可以撤回提交，另外可以再做修改。]]></content>
      <categories>
        <category>笔记</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Xshell管理虚拟机Ubuntu]]></title>
    <url>%2F2019%2F08%2F03%2Fxshell-vmware%2F</url>
    <content type="text"><![CDATA[因为使用VM虚拟机太过占用资源，所以我们可以用Xshell连接到虚拟机，来达到节省本机资源的目的。 安装SSH： 123sudo apt-get install openssh-serverservice iptables stop #关闭防火墙service ssh start #开启ssh服务 获得登录需要的ip ,在虚拟机输入： 1ifconfig ens*后面的inet后面的值就是ip。 按照我之前写过的xshell连接的教程 windows系统：Xshell下载安装+连接服务器 建立会话就ok，主机就是刚才你获得的ip，登录用的用户名和密码就是你安装时填的用户名(非root账户)和密码。 之后只需要打开虚拟机后最小化界面，从xshell登入就可以了。]]></content>
      <categories>
        <category>Xshell</category>
      </categories>
      <tags>
        <tag>Xshell</tag>
        <tag>虚拟机</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【thinkload】统计学习方法-第一章-统计学习方法概论]]></title>
    <url>%2F2019%2F08%2F03%2Ftongjixuexifangfa1%2F</url>
    <content type="text"><![CDATA[统计学习，学习为核心，统计为方法，学习是根据已有的经验归纳总结出潜在的规律并把所得运用到以后的行为中，]]></content>
      <categories>
        <category>thinkload</category>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>统计学习方法</tag>
        <tag>thinkload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我只是一个置顶介绍]]></title>
    <url>%2F2019%2F08%2F03%2Ftop%2F</url>
    <content type="text"><![CDATA[thinkload是一个字典里查不到词。 Thinkload, download something from my mind when thinking. Thinkload系列是我学习时的一些思考。 Notes系列是学习笔记。]]></content>
      <tags>
        <tag>thinkload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[photoshop cc 2019安装破解]]></title>
    <url>%2F2019%2F08%2F02%2Fphotoshop-cc-2019-download%2F</url>
    <content type="text"><![CDATA[Photoshop如今已经非常常用的处理图片的软件，本文就是介绍一下photoshop cc 2019安装破解的完整过程。 注：本文参考了http://www.3322.cc/soft/48343.html 下载creative cloud什么是creative cloud？creative cloud相当于adobe系列的一个应用商城，我们可以在里面安装各种adobe系列的软件。下载链接： 官网链接 网盘链接 下载完成直接按提示安装，然后注册adobe账号并登陆。 下载安装photoshop-cc-2019默认的下载位置在c盘，如果想改到其他盘可以点击右上角的三个点，出来菜单再点首选项。 然后点击creative Cloud界面，在安装位置条目处更改到你想安装到的位置。 打开creative cloud，找到photoshop的条目点击试用，photoshop自动下载安装成功。 利用补丁破解安装完成后安全起见先不要打开ps，我们先下载补丁工具。下载链接：网盘链接 其他链接 将压缩包里的adobe.photoshop.cc.2019.20.0.0-patch.exe文件解压到ps安装目录下，就是你刚才修改的安装位置，保证那个位置下有photoshop.exe文件。 然后点击运行补丁（你可能会听到一段诡异的音乐。。。）。 点击应用，等待出现文件补丁已成功完成的提示。 这样就破解完成了，这时再打开ps发现没有试用还有多少天的提醒了。 按照补丁制作者的建议，在 编辑 ==&gt; 首选项 ==&gt; 常规 ==&gt; 停用”主页”屏幕 打钩。 最后做好重启一下ps再试用。 注：这篇文章是我安装后就写了，我在安装完的七天后再次检验是否失效，如果失效我会更新补丁，如果补丁失效可以回来看我是否有更新方法。]]></content>
      <categories>
        <category>photoshop</category>
      </categories>
      <tags>
        <tag>破解</tag>
        <tag>photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xshell：在本地浏览器使用服务器的jupyter notebook]]></title>
    <url>%2F2019%2F08%2F02%2Fhexo-jupyter%2F</url>
    <content type="text"><![CDATA[有的服务器里只是命令行，无法可视化，可能就无法使用jupyter notebook。其实需要稍微修改一下连接的属性就能在本地浏览器里打开在服务器里启动的jupyter notebook，具体操作如下： 首先右击会话管理器里的服务器标签，在菜单点击属性。 然后点击左侧的隧道，然后再点击添加。 输入两个端口号，我这输入的是jupyter notebook默认的8888端口，然后点确定 然后再取消右下方转发X11连接到的选项，然后点确定。 之后双击会话管理器里的服务器进行连接，在命令行里输入jupyter notebook，启动后在浏览器里访问就会看到jupyter notebook的界面了。]]></content>
      <categories>
        <category>Xshell</category>
      </categories>
      <tags>
        <tag>Xshell</tag>
        <tag>jupyter notebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows系统：Xshell下载安装+连接服务器]]></title>
    <url>%2F2019%2F08%2F01%2FXshellDownload%2F</url>
    <content type="text"><![CDATA[学习深度学习需要足够的计算资源，往往需要连接远程服务器用来计算。本篇文章就介绍一下如何在windows系统里利用xshell连接服务器。 xshell下载安装首先要下载安装包:百度网盘资源。当然也可以去官网下载安装包，选择家庭学校免费版，下载前要填一下姓名邮箱，提交后你会收到带有下载链接的邮件。 点击安装包，然后一路默认下一步就ok。如果不想安装在c盘也可以，在其他盘里专门存xshell的各种文件，安装过程中只需把主文件夹换成你刚才的文件夹就ok。 建立连接 打开xshell后，点击左上角的文件然后点新建。 然后填入服务器名称、主机、端口号,然后点确定。 双击左侧会话管理器里刚建的服务器，在弹出的窗口里填入登录用的用户名，选上记住用户名。 然后输入密码，并选上记住密码。 点击确定以后就能在黑色的shell看到已经登录成功的提示了，然后就可以在shell里进行操作了。 之后登录只需要双击左侧会话管理器里的对应标签即可。 上传下载文件 在Linux主机上，安装上传下载工具包rz及sz，使用sudo apt install lrzsz 进行安装。 从Windows上传文件，上传命令为rz；输入命令后会弹出选择要上传的本地文件的窗口。 从Linux主机下载文件，下载命令为sz ，后面跟要下载的文件名。例如： sz helloworld.py。 然后就会弹出选择要保存到本机位置的窗口。 xshell的基本操作就说这些了，这些的操作已经基本够用了]]></content>
      <categories>
        <category>Xshell</category>
      </categories>
      <tags>
        <tag>Xshell</tag>
        <tag>linux服务器</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人生]]></title>
    <url>%2F2019%2F07%2F30%2FmyFirstArticle%2F</url>
    <content type="text"><![CDATA[一段旅程从2000年开始…… 到我写这段话已经过了十九年······ 什么样的旅程呢？ 当然是创造的伟大旅程！！！ 还记得小时候自己喜欢借用自己手边的东西组成各种奇形怪状的玩具、凭着各种感性认识在各种课本上画着各种有趣插画、反复读着被老师夸过的自己认真写过的作文、努力地独立想出解决卷子上颇具难度的问题的方法。。。。。。 各种自己花时间用心搞过的创造总是能给自己足够的乐趣与成就感，并且这种凝结着努力和价值的东西也诠释着存在的意义。每个人的人生其实都可以通过以时间为索引的一个自己参与过的值得叙述给别人的事件的列表总结，就像这样： “老子（老娘）年轻的时候，一个人······，可是到了中年，我来到了······，经历了我这一辈子不会忘记的事······，后来我老了，我打算去······，并且真的这么做了，一直想这样生活到现在······” 如何总结自己的一生？我想，不论是你拥有多少名利，得过多少荣誉，经历过多少难忘的事，这些可以被看作我们活着我们的行为创造过的各种沧桑岁月啊！我们投入过感情去创造的那些被自己认可的、有资格拿出来吹牛的经历将会成为我们一生的精炼内核。 所以我想： 我是人，我有自我的意识，我要自由地用自己真实感情驱使着不太完美的躯壳去创造出完美的生命光辉，光辉不必夺目，但我年老回头看时能使我不自主地淡淡微笑，最好是能像夕阳落山前发出的光芒一样，并不强烈刺眼，但非常美丽，也曾与讨厌的黑夜争过地盘，也曾点燃过那无边的海面······ 12345678910from people import mereal_lives = []for knowledge in ['math', 'deeplearning', 'python', ...]: me.learn(knowledge) real_lives.apend(me.create()) me.lives -= 1 —感谢阅读—]]></content>
      <categories>
        <category>一段话</category>
      </categories>
      <tags>
        <tag>人生</tag>
        <tag>创造</tag>
      </tags>
  </entry>
</search>
