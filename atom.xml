<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zinW&#39; s thinkload</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zinw623.github.io/"/>
  <updated>2019-08-11T13:46:36.903Z</updated>
  <id>https://zinw623.github.io/</id>
  
  <author>
    <name>zinW</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【notes】Deep Learning-1</title>
    <link href="https://zinw623.github.io/2019/08/11/DeepLearning-1/"/>
    <id>https://zinw623.github.io/2019/08/11/DeepLearning-1/</id>
    <published>2019-08-11T12:27:50.000Z</published>
    <updated>2019-08-11T13:46:36.903Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Three-Steps-for-DL"><a href="#Three-Steps-for-DL" class="headerlink" title="Three Steps for DL"></a>Three Steps for DL</h3><p>1.神经网络 –&gt; 2.成本函数 –&gt; 3.优化</p><ul><li><p>Step 1.神经网络就是一个由许多简单的函数组成的复杂函数。</p><blockquote><p>通常需要我们自己设计网络的结构，来让机器从数据中学习参数。</p></blockquote></li><li><p>Step 2.需要一个成本函数来评估参数和模型的好坏。</p><blockquote><p>我们通常基于任务来设计成本函数。</p></blockquote></li><li><p>Step 3.找出性能最好的函数的集合。(e.g. gradient descent)</p></li></ul><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><h4 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h4><p><img alt data-src="/uploads/DL/FC.PNG"></p><p>$ 每层的节点数：N_l $<br>$ 每个节点的输出： a^{l}_{i} $</p><blockquote><p>$ l 代表层数, i 代表的是第 l 层的第 i 个节点 $</p></blockquote><p>$ 一层中所有的输出组成一个长度为N_l的向量a^l $</p><p><img alt data-src="/uploads/DL/FCw.PNG"></p><p>$ 第l-1层的每个节点都与第l层的各个节点相连，两个相连的节点都对应一个参数w^{l}<em>{ij}，i是l层的第i个节点，j是l-1层的第j个节点。把所有w^{l}</em>{ij}组合成一个矩阵W^l，w^{l}<em>{ij}是第i行第j列的元素。总行数为N_l，总列数为N</em>{l-1} $</p><p>$ 同理偏置b^l_i和向量b^l $</p><p>$ z^l_i : 第l层神经元激活函数的输入 $<br>$ z^l : 向量第l层神经元激活函数的所有输入 $</p><p>$$ z^l_i = w^l_{il}a^{l-1}<em>{l} + w^l</em>{i2}a^{l-1}_2···+ b^l_i $$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Three-Steps-for-DL&quot;&gt;&lt;a href=&quot;#Three-Steps-for-DL&quot; class=&quot;headerlink&quot; title=&quot;Three Steps for DL&quot;&gt;&lt;/a&gt;Three Steps for DL&lt;/h3&gt;&lt;p&gt;1.神经网络
      
    
    </summary>
    
      <category term="笔记" scheme="https://zinw623.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Deep Learning" scheme="https://zinw623.github.io/categories/%E7%AC%94%E8%AE%B0/Deep-Learning/"/>
    
    
      <category term="笔记" scheme="https://zinw623.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Deep Learning" scheme="https://zinw623.github.io/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>thinkload</title>
    <link href="https://zinw623.github.io/2019/08/10/thinkload/"/>
    <id>https://zinw623.github.io/2019/08/10/thinkload/</id>
    <published>2019-08-10T07:53:41.000Z</published>
    <updated>2019-08-10T09:21:52.195Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Thinkload, download something from my mind when thinking.</strong></p></blockquote><a id="more"></a><h3 id="2019-08-10"><a href="#2019-08-10" class="headerlink" title="2019-08-10"></a>2019-08-10</h3><ul><li>要达到完全的确定性，在下定义的角度必然需要无穷个<strong>修饰词</strong>, 或者说解释无穷个足够的特性，或者说无穷个参数。</li><li>另一个角度，把具有存在的物体可以看做一个函数，一个从一个定义域（一个包含所有我们在意的物体的集合）映射到一个可观测领域的函数，对于这个可观测领域的人要准确确定其存在或理解其存在需要理解这个函数的所有参数。</li><li>而因为有很多观察角度，就有很多观测领域，对于每个领域的参数又显然是不同的，对一个领域准确注定对另一不同领域就不那么准确。</li><li>也可以说函数的参数确定了可观测领域，函数的参数里蕴含了可观测领域的性质，这么看物体本身到底是什么就不那么重要，更重要的是可观测领域的性质，更重要的是观察物体的角度。</li><li>那参数是怎么得到的呢？这里发现，我们认识一个新的物体的存在必然需要一些先天的或者一些先验的存在，比如视觉听觉等五感之类的，或者一些产生在大脑的感觉，更进一步是思维灵魂的东西，或者直接说自我的存在—一个观察者自我的存在。</li></ul><ul><li>之前思考问题时犯了个错，不该不严谨的将物体给以“个”的量词，使得思考范围被放到离散的物体分布。</li></ul><ul><li>可能通过“试错”的方式学习有效，和反复试验取频率作为概率的方法有效这件事有相似性。另外，大数定律的内在含义到底是什么？为什么反复试验起作用？</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Thinkload, download something from my mind when thinking.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="thinkload" scheme="https://zinw623.github.io/categories/thinkload/"/>
    
    
      <category term="thinkload" scheme="https://zinw623.github.io/tags/thinkload/"/>
    
  </entry>
  
  <entry>
    <title>【notes】docker学习笔记6-docker容器数据管理</title>
    <link href="https://zinw623.github.io/2019/08/09/docker-6/"/>
    <id>https://zinw623.github.io/2019/08/09/docker-6/</id>
    <published>2019-08-09T09:06:17.000Z</published>
    <updated>2019-08-09T12:14:33.803Z</updated>
    
    <content type="html"><![CDATA[<h3 id="docker容器的数据管理简介"><a href="#docker容器的数据管理简介" class="headerlink" title="docker容器的数据管理简介"></a>docker容器的数据管理简介</h3><ul><li>docker容器的数据卷</li><li>docker的数据卷容器</li><li>docker数据卷的备份和还原</li></ul><h3 id="docker容器的数据卷"><a href="#docker容器的数据卷" class="headerlink" title="docker容器的数据卷"></a>docker容器的数据卷</h3><h4 id="什么是数据卷-Data-Volume"><a href="#什么是数据卷-Data-Volume" class="headerlink" title="什么是数据卷(Data Volume)"></a>什么是数据卷(Data Volume)</h4><p>docker的生存周期是与运行的程序相一致的，而我们需要数据持久化，docker容器之间也需要共享一些数据</p><ul><li><p>数据卷是经过特殊设计的目录，可以绕过联合文件系统（UFS)，为一个或多个容器提供访问。</p></li><li><p>数据卷设计的目的，在于数据持久化，它完全对独立于容器的生存周期，因此docker不会在容器删除时删除其挂载的数据卷，也不会存在类似的垃圾收集机制，对容器引用的数据卷进行处理。</p></li><li><p>数据卷架构：</p><p>  <img alt data-src="/uploads/docker/5.PNG"></p><ul><li>docker数据卷独立于docker，独立运docker的生存周期。</li><li>docker数据卷位于docker的宿主机中文件系统。</li><li>docker数据卷既可以是目录也可是文件。</li><li>docker数据卷与宿主机进行数据共享。</li><li>同一目录或文件可以支持多个容器</li></ul></li><li><p>数据卷的特点</p><ul><li>数据卷在容器启动时初始化，如果容器使用的镜像在挂载点包含了数据，这些数据会拷贝到新初始化的数据卷中。</li><li>数据卷可以在容器之间共享和重用</li><li>可以对数据卷里的内容直接进行修改</li><li>数据卷的变化不会影响镜像的更新</li><li>卷会一直存在，即使挂载数据卷的容器已经被删除</li></ul></li></ul><h4 id="数据卷的使用"><a href="#数据卷的使用" class="headerlink" title="数据卷的使用"></a>数据卷的使用</h4><ul><li>为容器添加数据卷</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -v ~/container_data:/data -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>在本机系统的目录:在容器中映射的目录名</p><p>注：这种方式（bind mount)已不推荐使用，应使用volume方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker volume create my_volume <span class="comment"># 创建卷</span></span><br><span class="line">docker volume ls  <span class="comment"># 卷列表</span></span><br><span class="line">docker volume inspect my_volume <span class="comment">#卷信息</span></span><br><span class="line">docker volume rm my_volume <span class="comment"># 删除卷</span></span><br><span class="line"></span><br><span class="line">docker run -v [卷名]:[容器目录]:[选项列表] -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>详情：<a href="https://deepzz.com/post/the-docker-volumes-basic.html" target="_blank" rel="noopener">https://deepzz.com/post/the-docker-volumes-basic.html</a></p><ul><li>为数据卷添加访问权限</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -v [卷名]:[容器目录]:ro(访问权限) -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure><ul><li>使用dockerfile构建包含数据卷的镜像<br>dockerfile指令：<br>  VOLUME [“/data1”, “/data2”]</li></ul><p>不能映射到本地目录，并且运行同一镜像的不同容器所创建的数据卷也是不一样的。</p><h3 id="docker的数据卷容器"><a href="#docker的数据卷容器" class="headerlink" title="docker的数据卷容器"></a>docker的数据卷容器</h3><p>什么是数据卷容器：<br>    命名的容器挂载数据卷，其他容器通过挂载这个容器实现数据共享，挂载数据卷的容器，就叫做数据卷容器</p><p>图示：</p><p><img alt data-src="/uploads/docker/6.PNG"></p><ul><li>挂载数据卷容器的方法</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --volumes-from [CONTAINER NAME]</span><br></pre></td></tr></table></figure><p>如果数据卷容器删除（即使同时删除挂载的数据卷）后，挂载该数据卷容器的容器的数据目录仍存在且有效。</p><p>数据卷容器的作用仅仅是将数据卷挂载的配置传递到挂载了数据卷容器的新容器中。</p><h3 id="docker数据卷的备份与还原"><a href="#docker数据卷的备份与还原" class="headerlink" title="docker数据卷的备份与还原"></a>docker数据卷的备份与还原</h3><ul><li>数据备份方法</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --volumes-from [container name] -v $(<span class="built_in">pwd</span>):/backup ubuntu tar cvf /backup/backup.tar [container data volume]</span><br></pre></td></tr></table></figure><p><img alt data-src="/uploads/docker/7.PNG"></p><ul><li>数据还原方法</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --volumes-from [container name] -v $(<span class="built_in">pwd</span>):/backup ubuntu tar xvf /backup/backup.tar [container data volume]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;docker容器的数据管理简介&quot;&gt;&lt;a href=&quot;#docker容器的数据管理简介&quot; class=&quot;headerlink&quot; title=&quot;docker容器的数据管理简介&quot;&gt;&lt;/a&gt;docker容器的数据管理简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;docker容器的数据卷
      
    
    </summary>
    
      <category term="笔记" scheme="https://zinw623.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="docker" scheme="https://zinw623.github.io/categories/%E7%AC%94%E8%AE%B0/docker/"/>
    
    
      <category term="docker" scheme="https://zinw623.github.io/tags/docker/"/>
    
      <category term="笔记" scheme="https://zinw623.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【notes】docker学习笔记5-dockerfile</title>
    <link href="https://zinw623.github.io/2019/08/08/docker-5/"/>
    <id>https://zinw623.github.io/2019/08/08/docker-5/</id>
    <published>2019-08-08T03:27:42.000Z</published>
    <updated>2019-08-08T12:20:07.098Z</updated>
    
    <content type="html"><![CDATA[<h3 id="dockerfile指令"><a href="#dockerfile指令" class="headerlink" title="dockerfile指令"></a>dockerfile指令</h3><h4 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h4><p>注释： # Comment<br>指令： INSTRUCTION argument</p><h5 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h5><ul><li>FROM &lt;image&gt;</li><li>FROM &lt;image&gt;:&lt;tag&gt;</li><li>必须已经存在的镜像，也就是基础镜像</li><li>必须是第一条非注释指令</li></ul><h5 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h5><ul><li>MAINTAINER &lt;name&gt;<br>  指定镜像的作者信息，包含镜像的所有者和练习方式</li></ul><h5 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h5><p><strong>构建构成运行的</strong></p><ul><li>RUN &lt;command&gt;  (shell模式)<br>  /bin/sh -c command</li><li>RUN [“executable”, “param1”, “param2”]  (exec模式)<br>  RUN[“/bin/bash”, “-c”, “echo hello”]</li></ul><h5 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h5><ul><li>EXPOSE &lt;port&gt; [&lt;port&gt;…]<br>  指定运行该镜像的容器使用的端口，但只是告诉docker会使用特定的端口号，出于安全考虑不会自动打开，在容器运行时仍需要手动指定端口映射。<h5 id="CMD-ENTERYPOINT"><a href="#CMD-ENTERYPOINT" class="headerlink" title="CMD ENTERYPOINT"></a>CMD ENTERYPOINT</h5></li></ul><p><strong>指定容器启动时运行的命令</strong></p><ul><li>CMD [“executable”, “param1”, “param2”] (exec模式)</li><li>CMD command param1 param2 (shell模式)</li><li>CMD [“params1”, “params2”] (作为ENTRYPOINT指令的默认参数)</li></ul><p>在docker run时如果指定命令的话dockerfile里的cmd命令会被覆盖掉。</p><ul><li>ENTRYPOINT [“executable”, “param1”, “param2”] (exec模式)</li><li>ENTRYPOINT command param1 param2 (shell模式)</li></ul><p>默认不会被覆盖，如果需要覆盖需要指定docker run –entrypoint 覆盖</p><h5 id="ADD-COPY-VOLUME"><a href="#ADD-COPY-VOLUME" class="headerlink" title="ADD COPY VOLUME"></a>ADD COPY VOLUME</h5><p><strong>设置镜像的目录和文件</strong></p><ul><li><p>ADD &lt;src&gt;…&lt;dest&gt;</p></li><li><p>ADD [“&lt;src”…”<dest>“] (适用于文件路径中有空格)</dest></p></li><li><p>COPY &lt;src&gt;…&lt;dest&gt;</p></li><li><p>COPY  [“&lt;src”…”<dest>“] (适用于文件路径中有空格)</dest></p></li></ul><p>可以使文件地址（构建目录的相对地址），也可以是远程url（推荐使用curl获取文件内容）</p><ul><li><p>ADD vs. COPY<br>  ADD包含类似tar的解压功能<br>  如果单纯复制文件，docker推荐使用COPY</p></li><li><p>VOLUME [“/data”]<br>  添加卷  </p></li></ul><h5 id="WORKDIR-ENV-USER"><a href="#WORKDIR-ENV-USER" class="headerlink" title="WORKDIR ENV USER"></a>WORKDIR ENV USER</h5><p><strong>构建及容器运行时的环境设置</strong></p><ul><li>WORKDIR /path/to/workdir  (设置工作目录，通常使用绝对路径，否则会一直传递下去)</li></ul><p>e.g:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR C</span><br><span class="line">RUN <span class="built_in">pwd</span>  <span class="comment"># 结果为 /a/b/c</span></span><br></pre></td></tr></table></figure><ul><li>ENV &lt;key&gt;&lt;value&gt;</li><li>ENV &lt;key&gt;=&lt;value&gt;</li></ul><p>设置环境变量</p><ul><li>USER daemon</li></ul><p>USER user           USER uid<br>USER user:group     USER uid:gid<br>USER user:gid       USER uid:group</p><p>指定运行的用户，若不指定则默认root用户。</p><h5 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h5><ul><li>ONBUILD [INSTRUCTION]</li><li>镜像触发器</li><li>当一个镜像被其他镜像作为基础镜像时执行</li><li>会在构建过程中插入指令 </li></ul><h4 id="dockerfile构建过程"><a href="#dockerfile构建过程" class="headerlink" title="dockerfile构建过程"></a>dockerfile构建过程</h4><ul><li>从基础镜像运行一个容器</li><li>执行一条指令，对容器作出修改</li><li>执行类似docker commit的操作， 提交一个新的镜像层（中间层镜像）</li><li>再基于刚提交的镜像运行一个新的容器</li><li>执行dockerfile中的下一条指令，直至所有指令执行完毕</li></ul><ul><li><p>中间层镜像进行调试  注：dockerfile会删除中间层镜像容器但不会删除中间层镜像</p></li><li><p>构建缓存，构建时会建立缓存，因此第二次执行构建命令会很快，是因为使用了缓存。</p></li><li><p>不使用缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --no-cache</span><br></pre></td></tr></table></figure></li><li><p>另一种方法通过更改缓存刷新时间</p></li></ul><blockquote><p>FROM Ubuntu:14:04<br>MAINTAINER dormancypress <a href="mailto:user@mail.com" target="_blank" rel="noopener">user@mail.com</a><br>ENV REFRESH_DATE 2019-08-08<br>RUN apt-get update<br>RUN apt-get install -y nginx<br>EXPOSE 80</p></blockquote><p>修改REFRESH_DATE时间</p><ul><li>查看镜像构建过程</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">history</span> [image]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;dockerfile指令&quot;&gt;&lt;a href=&quot;#dockerfile指令&quot; class=&quot;headerlink&quot; title=&quot;dockerfile指令&quot;&gt;&lt;/a&gt;dockerfile指令&lt;/h3&gt;&lt;h4 id=&quot;指令格式&quot;&gt;&lt;a href=&quot;#指令格式&quot; cla
      
    
    </summary>
    
      <category term="笔记" scheme="https://zinw623.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="docker" scheme="https://zinw623.github.io/categories/%E7%AC%94%E8%AE%B0/docker/"/>
    
    
      <category term="docker" scheme="https://zinw623.github.io/tags/docker/"/>
    
      <category term="笔记" scheme="https://zinw623.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【notes】docker学习笔记4-docker客户端与守护进程</title>
    <link href="https://zinw623.github.io/2019/08/07/docker-4/"/>
    <id>https://zinw623.github.io/2019/08/07/docker-4/</id>
    <published>2019-08-07T10:31:41.000Z</published>
    <updated>2019-08-08T03:07:56.995Z</updated>
    
    <content type="html"><![CDATA[<h3 id="docker的C-S模式"><a href="#docker的C-S模式" class="headerlink" title="docker的C/S模式"></a>docker的C/S模式</h3><p><img alt data-src="/uploads/docker/4.PNG"></p><h4 id="客户端与守护进程通信的接口"><a href="#客户端与守护进程通信的接口" class="headerlink" title="客户端与守护进程通信的接口"></a>客户端与守护进程通信的接口</h4><ol><li>命令行接口</li><li>remote API：<ul><li>RESTful风格API</li><li>STDIN STDOUT STDERR</li><li>语言参考：<a href="https://docs.docker.com/reference/api/docker_remote_api" target="_blank" rel="noopener">https://docs.docker.com/reference/api/docker_remote_api</a></li></ul></li></ol><h4 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h4><ul><li>unix:///var/run/docker.sock  默认方式</li><li>tcp://host:port</li><li>fd://socketfd</li></ul><h4 id="利用socket进行通信"><a href="#利用socket进行通信" class="headerlink" title="利用socket进行通信"></a>利用socket进行通信</h4><ul><li>查看正在运行的守护进程</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep docker</span><br></pre></td></tr></table></figure><ul><li>连接socket进行通信</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -U /var/run/docker.sock</span><br><span class="line">GET /info HTTP/1.1</span><br></pre></td></tr></table></figure><p>以上都是在本地的访问，docker也支持远程访问。</p><h3 id="docker守护进程的配置和操作"><a href="#docker守护进程的配置和操作" class="headerlink" title="docker守护进程的配置和操作"></a>docker守护进程的配置和操作</h3><ul><li>查看守护进程</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep docker</span><br><span class="line">sudo status docker</span><br></pre></td></tr></table></figure><ul><li>守护进程的启动、停止和重启</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service docker start</span><br><span class="line">sudo service docker stop</span><br><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure><ul><li><p>docker的启动选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -d [OPTIONS]  <span class="comment">#所以守护形式运行</span></span><br></pre></td></tr></table></figure></li><li><p>运行相关:<br>  -D, –debug = false<br>  -e, –exec-driver = “native”<br>  -g, –graph = “/var/lib/docker”<br>  –icc = true<br>  -l, –log-level = “info”<br>  –label = []<br>  -p, –pidfile = “/var/run/docker.pid”</p></li><li><p>docker服务器连接相关：<br>  -G, –group = “docker”<br>  -H, –host = []<br>  –tls = false<br>  –tlscacert = “/home/sven/.docker/ca.pem”<br>  –tlscert = “/home/sven/.docker/cert.pem”<br>  –tlskey = “/home/sven/.docker/key.pem”<br>  –tlsverify = false</p></li><li><p>RemotAPI相关：<br>  –api-enable-cors = false</p></li><li><p>Registry相关：<br>  –insecure-registry = []<br>  –registry-mirror = []</p></li><li><p>网络设置相关：<br>  -b, –bridge = “”<br>  –bip = “”<br>  –fixed-cidr = “”<br>  –fixed-cidr-v6 = “”<br>  –dns = []<br>  –dns-search = []<br>  –ip = 0.0.0.0<br>  –ip-forward = true<br>  –ip-masq = true<br>  –iptables = true<br>  –ipv6 = false<br>  –mtu = 0</p></li><li><p>启动配置文件  /etc/default/docker<br>  注：ubuntu 16.04及以上版本使用：</p><pre><code>修改/lib/systemd/system/docker.service中的ExecStart加载配置：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">service docker restart</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure></code></pre></li></ul><h3 id="docker的远程访问"><a href="#docker的远程访问" class="headerlink" title="docker的远程访问"></a>docker的远程访问</h3><ul><li>第二台安装docker的服务器</li><li>保证Client API与Server API版本一致</li></ul><h4 id="修改docker守护进程启动选项"><a href="#修改docker守护进程启动选项" class="headerlink" title="修改docker守护进程启动选项"></a>修改docker守护进程启动选项</h4><ul><li><p>修改服务器端配置<br>  -H  tcp://host:post</p><pre><code>unix:///path/to/socket fd://* or fd//socketfd</code></pre><p>  守护进程默认配置：</p><pre><code>-H unix:///var/run/docker.sock注：我的默认的是 fd://</code></pre><p>  改为 tcp:</p><pre><code>tcp://0.0.0.0:2375</code></pre>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://ip:2375/info</span><br></pre></td></tr></table></figure></li><li><p>修改客户端配置<br>  -H  tcp://host:post</p><pre><code>unix:///path/to/socket fd://* or fd//socketfd</code></pre><p>  默认配置：</p><pre><code>-H unix:///var/run/docker.sock</code></pre><ol><li>docker -H tcp//ip:2375 # 太麻烦</li><li>export DOCKET_HOST=”tcp://ip:2357” # 使用环境变量<br> export DOCKET_HOST=”tcp://ip:2357”  # 使用本地</li></ol></li></ul><ul><li>怎样在设置了远程连接的服务器也支持本机连接？<br>答：给-H再增加一个方式，-H可以设置多个值。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;docker的C-S模式&quot;&gt;&lt;a href=&quot;#docker的C-S模式&quot; class=&quot;headerlink&quot; title=&quot;docker的C/S模式&quot;&gt;&lt;/a&gt;docker的C/S模式&lt;/h3&gt;&lt;p&gt;&lt;img alt data-src=&quot;/uploads/do
      
    
    </summary>
    
      <category term="笔记" scheme="https://zinw623.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="docker" scheme="https://zinw623.github.io/categories/%E7%AC%94%E8%AE%B0/docker/"/>
    
    
      <category term="docker" scheme="https://zinw623.github.io/tags/docker/"/>
    
      <category term="笔记" scheme="https://zinw623.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【notes】docker学习笔记3-docker镜像</title>
    <link href="https://zinw623.github.io/2019/08/06/docker-3/"/>
    <id>https://zinw623.github.io/2019/08/06/docker-3/</id>
    <published>2019-08-06T13:17:53.000Z</published>
    <updated>2019-08-06T16:06:44.693Z</updated>
    
    <content type="html"><![CDATA[<h3 id="查看和删除镜像"><a href="#查看和删除镜像" class="headerlink" title="查看和删除镜像"></a>查看和删除镜像</h3><ul><li>镜像的存储位置：/var/lib/docker</li></ul><h4 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images [OPSIONS] [REPOSITORY]</span><br></pre></td></tr></table></figure><blockquote><p>   -a, –all = false   # 显示所有镜像，默认并不显示中间层镜像（没有标签名的镜像）<br>   -f, –filter = []   # 过滤条件<br>   –no-trunc = false  # 不使用截断的形式来显示数据(默认使用截断显示EID，比文件名短)<br>   -q, –quiet = false # 只显示EID</p></blockquote><h4 id="镜像标签和仓库"><a href="#镜像标签和仓库" class="headerlink" title="镜像标签和仓库"></a>镜像标签和仓库</h4><ul><li><p>镜像仓库<br>  区分：</p><ul><li><p>REPOSITORY 仓库</p></li><li><p>REGISTRY 仓库</p><p>REGISTRY里会有很多REPOSITORY仓库，每个REPOSITORY里会有一个个独立的镜像。</p></li></ul></li><li><p>标签 TAG</p><ul><li><p>镜像的名字 = 镜像仓库名 : 镜像标签    –对应–&gt;   镜像ID </p><p>ubuntu:latest, ubuntu:14.04, …..</p></li><li><p>如果没有指定标签，默认为latest。</p></li><li><p>同一仓库的不同标签可以对应同一镜像ID，也就是说可以根据需求给同一镜像文件打上不同的标签。</p></li><li><p>没有标签名的镜像称作中间层镜像。</p></li></ul></li></ul><h4 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [OPTIONS] CONTIANER|IMAGE [CONTAINER|IMAGE...]</span><br></pre></td></tr></table></figure><blockquote><p>   -f, –format=””</p></blockquote><h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure><blockquote><p>   -f, –force = false  强制删除<br>   –no-prune = false  不删除未打标签的父镜像<br>   对应多个标签的镜像文件可以直接用ID选定所有标签</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi ID</span><br></pre></td></tr></table></figure><h3 id="获取和推送镜像"><a href="#获取和推送镜像" class="headerlink" title="获取和推送镜像"></a>获取和推送镜像</h3><h4 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h4><ul><li><p>Docker Hub<br>  <a href="https://registry.hub.docker.com" target="_blank" rel="noopener">https://registry.hub.docker.com</a></p></li><li><p>docker search</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search [OPTIONS] TERM</span><br></pre></td></tr></table></figure><blockquote><p>   –automated = false<br>   –no-trunc = false<br>   -s, stars = 0   只显示最少多少stars的<br>   最多返回25个结果</p></blockquote><h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [OPTIONS] NAME [:TAG]</span><br></pre></td></tr></table></figure><blockquote><p>   -a, –all-tags = false 下载仓库中所有被标记的镜像</p></blockquote><h4 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push username/IMAGE</span><br></pre></td></tr></table></figure><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><ul><li>保存对容器的修改，并再次使用</li><li>自定义镜像的能力</li><li>以软件的形式打包并分发服务及其运行环境</li></ul><h4 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h4><p>通过容器构建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><blockquote><p>   -a, –author=”” Author<br>       e.g., “John Hannibal Smith <a href="mailto:hannibal@a-team.com" target="_blank" rel="noopener">hannibal@a-team.com</a>“<br>   -m, –message=””    记录构建的信息<br>   -p, –pause = true  不暂停容器的运行</p></blockquote><h4 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h4><p>通过Dockerfile文件构建</p><p>dockerfile:</p><blockquote><p> <strong>#First Dockerfile</strong><br>FROM ubuntu:14.04<br>MAINTAINER dormancypress “<a href="mailto:dormancypress@outlook.com" target="_blank" rel="noopener">dormancypress@outlook.com</a><br>RUN apt-get update<br>RUN apt-get install -y nginx<br>EXPOSE 80</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [OPTIONS] PATH|URL|-</span><br></pre></td></tr></table></figure><blockquote><p>   –force-rm = false<br>   –no-cache = false<br>   –pull=false<br>   -q,–quiet = false<br>   –rm = true<br>   -t, –tag=””</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;查看和删除镜像&quot;&gt;&lt;a href=&quot;#查看和删除镜像&quot; class=&quot;headerlink&quot; title=&quot;查看和删除镜像&quot;&gt;&lt;/a&gt;查看和删除镜像&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;镜像的存储位置：/var/lib/docker&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;列
      
    
    </summary>
    
      <category term="笔记" scheme="https://zinw623.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="docker" scheme="https://zinw623.github.io/categories/%E7%AC%94%E8%AE%B0/docker/"/>
    
    
      <category term="docker" scheme="https://zinw623.github.io/tags/docker/"/>
    
      <category term="笔记" scheme="https://zinw623.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【notes】docker学习笔记2-docker容器</title>
    <link href="https://zinw623.github.io/2019/08/06/docker-2/"/>
    <id>https://zinw623.github.io/2019/08/06/docker-2/</id>
    <published>2019-08-06T07:21:42.000Z</published>
    <updated>2019-08-06T15:45:01.235Z</updated>
    
    <content type="html"><![CDATA[<h3 id="容器的基本操作"><a href="#容器的基本操作" class="headerlink" title="容器的基本操作"></a>容器的基本操作</h3><h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><ul><li><p>仅一次命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run IMAGE [COMMAND] [ARG]</span><br></pre></td></tr></table></figure></li><li><p>启动交互式容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -i -t IMAGE /bin/bash</span><br></pre></td></tr></table></figure></li></ul><p>-i –interactive=ture | false 默认是false，为容器始终打开标准输入<br>-t –tty=true | false 默认是false，分配一个终端</p><ul><li><p>自定义容器名字</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=自定义名 -i -t IMAGE /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>重新启动已建立的容器<br>docker start [-i] 容器名</p></li></ul><h4 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h4><ul><li><p>不加参数是正在运行的容器，-a是所有容器，-l是最新创建的一个容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps [-a] [-l]</span><br></pre></td></tr></table></figure></li><li><p>查看容器参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [ID] or [name]</span><br></pre></td></tr></table></figure></li></ul><h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器名</span><br></pre></td></tr></table></figure><h3 id="守护式容器"><a href="#守护式容器" class="headerlink" title="守护式容器"></a>守护式容器</h3><p>什么是守护式容器：</p><ul><li>能够长期运行</li><li>没有交互式会话</li></ul><h4 id="以守护形式运行容器："><a href="#以守护形式运行容器：" class="headerlink" title="以守护形式运行容器："></a>以守护形式运行容器：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -i -t IMAGE /bin/bash</span><br><span class="line">Ctrl + P Ctrl + Q</span><br></pre></td></tr></table></figure><h4 id="附加到运行中的容器"><a href="#附加到运行中的容器" class="headerlink" title="附加到运行中的容器"></a>附加到运行中的容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach 容器名</span><br></pre></td></tr></table></figure><h4 id="启动守护式容器"><a href="#启动守护式容器" class="headerlink" title="启动守护式容器"></a>启动守护式容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d 镜像名 [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><h4 id="得知容器运行情况"><a href="#得知容器运行情况" class="headerlink" title="得知容器运行情况"></a>得知容器运行情况</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs [-f] [-t] [--tail] 容器名</span><br></pre></td></tr></table></figure><p>-f –follows=true | false 默认为false  一直跟踪日志变化并返回结果<br>-t –timestamps=true | false 默认为false  结果加上时间戳<br>–tail= “all”  多少数量的日志</p><h4 id="查看运行中容器进程"><a href="#查看运行中容器进程" class="headerlink" title="查看运行中容器进程"></a>查看运行中容器进程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器名</span><br></pre></td></tr></table></figure><h4 id="在运行中的容器内启动新进程"><a href="#在运行中的容器内启动新进程" class="headerlink" title="在运行中的容器内启动新进程"></a>在运行中的容器内启动新进程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> [-d] [-i] [-t] 容器名 [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><h4 id="停止守护式容器"><a href="#停止守护式容器" class="headerlink" title="停止守护式容器"></a>停止守护式容器</h4><ul><li><p>发送指令等待停止</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器名</span><br></pre></td></tr></table></figure></li><li><p>直接停止容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">kill</span> 容器名</span><br></pre></td></tr></table></figure></li></ul><p>###在容器中部署静态网站</p><h4 id="设置容器的端口映射"><a href="#设置容器的端口映射" class="headerlink" title="设置容器的端口映射"></a>设置容器的端口映射</h4><p>run [-P]</p><ul><li><p>-P , –publish-all = true | false 默认为false  为容器暴露的所有端口设置映射</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -P -t -i ubuntu /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>-p , 指定端口</p><ul><li><p>容器端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80 -i -t ubuntu /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>宿主机端口:容器端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:80 -i -t ubuntu /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>ip::容器端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 0.0.0.0:80 -i -t ubuntu /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>ip:宿主机端口:容器端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 0.0.0.0:8080:80 -i -t ubuntu /bin/bash</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="Nginx部署"><a href="#Nginx部署" class="headerlink" title="Nginx部署"></a>Nginx部署</h4><ul><li><p>创建映射80端口的交互式容器</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80 --name web -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>安装Nginx</p></li><li><p>安装文本编辑器vim</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get upgrade</span><br><span class="line">apt-get install nginx -y</span><br><span class="line">apt-get install vim -y</span><br></pre></td></tr></table></figure></li><li><p>创建静态页面</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /var/www/html</span><br><span class="line">vim index.html</span><br></pre></td></tr></table></figure></li><li><p>修改Nginx配置文件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/sites-enabled/default</span><br></pre></td></tr></table></figure></li><li><p>运行Nginx</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br><span class="line">ps -ef</span><br><span class="line">Ctrl P Ctrl Q</span><br></pre></td></tr></table></figure></li><li><p>验证网站访问</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker port web <span class="comment"># 查看端口映射情况</span></span><br><span class="line">docker top web <span class="comment"># 查看进程运行情况</span></span><br><span class="line">docker inspect web <span class="comment">#查看ip</span></span><br><span class="line">curl http://172.17.0.2</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;容器的基本操作&quot;&gt;&lt;a href=&quot;#容器的基本操作&quot; class=&quot;headerlink&quot; title=&quot;容器的基本操作&quot;&gt;&lt;/a&gt;容器的基本操作&lt;/h3&gt;&lt;h4 id=&quot;启动容器&quot;&gt;&lt;a href=&quot;#启动容器&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="笔记" scheme="https://zinw623.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="docker" scheme="https://zinw623.github.io/categories/%E7%AC%94%E8%AE%B0/docker/"/>
    
    
      <category term="docker" scheme="https://zinw623.github.io/tags/docker/"/>
    
      <category term="笔记" scheme="https://zinw623.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【notes】docker学习笔记1-docker基本组成</title>
    <link href="https://zinw623.github.io/2019/08/06/docker-1/"/>
    <id>https://zinw623.github.io/2019/08/06/docker-1/</id>
    <published>2019-08-06T02:30:45.000Z</published>
    <updated>2019-08-08T12:29:30.031Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h3><ul><li>Docker Client 客户端</li><li>Docker Daemon 守护进程</li><li>Docker Image 镜像</li><li>Docker Container 容器</li><li>Docker Registry 仓库</li></ul><h4 id="Docker客户端-守护进程"><a href="#Docker客户端-守护进程" class="headerlink" title="Docker客户端/守护进程"></a>Docker客户端/守护进程</h4><ul><li>C/S架构</li><li>docker客户端对服务器的访问： 本地/远程</li><li>docker客户端向发送给守护进程请求，守护进程的执行结果还会传回给客户端。</li></ul><h4 id="Docker-Image镜像"><a href="#Docker-Image镜像" class="headerlink" title="Docker Image镜像"></a>Docker Image镜像</h4><ul><li>构建和打包阶段。</li><li>容器的基石，相当于保存了容器运行需要的源代码。</li><li>层叠的层叠文件系统。 bootfs（引导文件系统）-&gt; rootfs(Ubuntu) -&gt; add emacs -&gt; add Apache</li><li>联合加载（union mount）:一次加载多个文件系统（add Apache，add emacs），将所有文件系统叠加在一切。镜像可以叠加在一起，位于底部的成为基础镜像（rootfs），add emacs（副镜像）。</li></ul><h4 id="Docker-Container容器"><a href="#Docker-Container容器" class="headerlink" title="Docker Container容器"></a>Docker Container容器</h4><ul><li>通过镜像启动。</li><li>启动执行阶段。</li><li>配置数据和镜像层（bootfs -&gt; ······ -&gt; add emacs) -&gt; 可写层。</li><li>写时复制：docker出现变化时都会应用到可写层，先从只读镜像层复制到可写层然后只读层的文件被隐藏。</li></ul><h4 id="Docker-Registry仓库"><a href="#Docker-Registry仓库" class="headerlink" title="Docker Registry仓库"></a>Docker Registry仓库</h4><ul><li>保存docker镜像。</li><li>分为公有和私有。公有：Docker Hub</li></ul><h4 id="图示结构"><a href="#图示结构" class="headerlink" title="图示结构"></a>图示结构</h4><p>Docker:</p><p><img alt data-src="/uploads/docker/0.PNG"></p><p>Docker Image:</p><p><img alt data-src="/uploads/docker/1.PNG"></p><p>Docker Container:</p><p><img alt data-src="/uploads/docker/2.PNG"></p><h4 id="docker基本指令"><a href="#docker基本指令" class="headerlink" title="docker基本指令"></a>docker基本指令</h4><ul><li><p>查找镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search tutorial</span><br></pre></td></tr></table></figure></li><li><p>下载镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull learn/tutorial</span><br></pre></td></tr></table></figure></li><li><p>启动一个容器，使用echo命令输出hello world</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run learn/tutorial <span class="built_in">echo</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure></li><li><p>启动一个容器下载ping</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run learn/tutorial apt-get install -y ping</span><br></pre></td></tr></table></figure></li><li><p>查看有哪些容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -l</span><br></pre></td></tr></table></figure></li><li><p>提交容器，即创建一个新的镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [docker ID] learn/ping</span><br></pre></td></tr></table></figure></li><li><p>用新镜像建立一个容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run learn/ping ping www.baidu.com</span><br></pre></td></tr></table></figure></li><li><p>查看容器信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [docker ID]</span><br></pre></td></tr></table></figure></li><li><p>查看有哪些镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image</span><br></pre></td></tr></table></figure></li><li><p>将镜像保存到docker hub上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push /learn/ping</span><br></pre></td></tr></table></figure></li></ul><h3 id="Docker容器相关技术简介"><a href="#Docker容器相关技术简介" class="headerlink" title="Docker容器相关技术简介"></a>Docker容器相关技术简介</h3><h4 id="Docker依赖的Linux内核特性"><a href="#Docker依赖的Linux内核特性" class="headerlink" title="Docker依赖的Linux内核特性"></a>Docker依赖的Linux内核特性</h4><ul><li><p>Namespaces 命名空间<br>  提供了系统资源的隔离，for轻量级虚拟化服务<br>  五种命名空间：</p><ul><li>PID 进程隔离</li><li>NET 管理网络接口</li><li>IPC 管理跨进程通信的访问</li><li>MNT 管理挂载点</li><li>UTS 隔离内核和版本标识</li></ul></li><li><p>Control groups 控制组</p><ul><li>资源限制（内存上限等）</li><li>优先级设定（设定哪些进程组使用哪些资源）</li><li>资源计量</li><li>资源控制（挂起恢复）</li></ul></li></ul><h4 id="Docker容器的能力"><a href="#Docker容器的能力" class="headerlink" title="Docker容器的能力"></a>Docker容器的能力</h4><ul><li>文件系统隔离：每个容器都有自己的root文件系统</li><li>进程隔离： 每个容器都运行在自己的进程环境中</li><li>网络隔离： 容器间的虚拟网络接口和IP地址都是分开的</li><li>资源隔离和分组：使用cgroups将CPU和内存之类的资源独立分配给每个Docker容器</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Docker的基本组成&quot;&gt;&lt;a href=&quot;#Docker的基本组成&quot; class=&quot;headerlink&quot; title=&quot;Docker的基本组成&quot;&gt;&lt;/a&gt;Docker的基本组成&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Docker Client 客户端&lt;/li&gt;
&lt;li&gt;D
      
    
    </summary>
    
      <category term="笔记" scheme="https://zinw623.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="docker" scheme="https://zinw623.github.io/categories/%E7%AC%94%E8%AE%B0/docker/"/>
    
    
      <category term="docker" scheme="https://zinw623.github.io/tags/docker/"/>
    
      <category term="笔记" scheme="https://zinw623.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>用Xshell管理虚拟机Ubuntu</title>
    <link href="https://zinw623.github.io/2019/08/03/xshell-vmware/"/>
    <id>https://zinw623.github.io/2019/08/03/xshell-vmware/</id>
    <published>2019-08-03T14:14:16.000Z</published>
    <updated>2019-08-05T10:31:08.285Z</updated>
    
    <content type="html"><![CDATA[<p>因为使用VM虚拟机太过占用资源，所以我们可以用Xshell连接到虚拟机，来达到节省本机资源的目的。</p><a id="more"></a><ol><li>安装SSH： </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br><span class="line">service iptables stop <span class="comment">#关闭防火墙</span></span><br><span class="line">service ssh start <span class="comment">#开启ssh服务</span></span><br></pre></td></tr></table></figure><ol start="2"><li>获得登录需要的ip ,在虚拟机输入：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><img width="50%" data-src="/uploads/xshell-vmware/1.PNG"><p>ens*后面的inet后面的值就是ip。</p><ol start="3"><li><p>按照我之前写过的xshell连接的教程 <a href="/2019/08/01/XshellDownload/">windows系统：Xshell下载安装+连接服务器</a> 建立会话就ok，主机就是刚才你获得的ip，登录用的用户名和密码就是你安装时填的用户名(非root账户)和密码。</p></li><li><p>之后只需要打开虚拟机后最小化界面，从xshell登入就可以了。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为使用VM虚拟机太过占用资源，所以我们可以用Xshell连接到虚拟机，来达到节省本机资源的目的。&lt;/p&gt;
    
    </summary>
    
      <category term="Xshell" scheme="https://zinw623.github.io/categories/Xshell/"/>
    
    
      <category term="Xshell" scheme="https://zinw623.github.io/tags/Xshell/"/>
    
      <category term="虚拟机" scheme="https://zinw623.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="Ubuntu" scheme="https://zinw623.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>photoshop cc 2019安装破解</title>
    <link href="https://zinw623.github.io/2019/08/02/photoshop-cc-2019-download/"/>
    <id>https://zinw623.github.io/2019/08/02/photoshop-cc-2019-download/</id>
    <published>2019-08-02T03:08:27.000Z</published>
    <updated>2019-08-08T03:22:57.465Z</updated>
    
    <content type="html"><![CDATA[<p>Photoshop如今已经非常常用的处理图片的软件，本文就是介绍一下photoshop cc 2019安装破解的完整过程。</p><p>注：本文参考了<a href="http://www.3322.cc/soft/48343.html" target="_blank" rel="noopener">http://www.3322.cc/soft/48343.html</a></p><a id="more"></a><h3 id="下载creative-cloud"><a href="#下载creative-cloud" class="headerlink" title="下载creative cloud"></a>下载creative cloud</h3><p>什么是creative cloud？creative cloud相当于adobe系列的一个应用商城，我们可以在里面安装各种adobe系列的软件。<br>下载链接： <a href="https://creativecloud.adobe.com/apps/download/creative-cloud?promoid=KSPDX" target="_blank" rel="noopener">官网链接</a>       <a href="https://pan.baidu.com/s/1qr6U3l48Nr-pakBNumR7Tw" target="_blank" rel="noopener">网盘链接</a></p><p>下载完成直接按提示安装，然后注册adobe账号并登陆。</p><h3 id="下载安装photoshop-cc-2019"><a href="#下载安装photoshop-cc-2019" class="headerlink" title="下载安装photoshop-cc-2019"></a>下载安装photoshop-cc-2019</h3><p>默认的下载位置在c盘，如果想改到其他盘可以点击右上角的三个点，出来菜单再点首选项。</p><img width="50%" data-src="/uploads/downloadPS/3.PNG"><p>然后点击creative Cloud界面，在安装位置条目处更改到你想安装到的位置。</p><img width="50%" data-src="/uploads/downloadPS/4.PNG"><p>打开creative cloud，找到photoshop的条目点击试用，photoshop自动下载安装成功。</p><img width="50%" data-src="/uploads/downloadPS/5.PNG"><img width="50%" data-src="/uploads/downloadPS/1.PNG"><h3 id="利用补丁破解"><a href="#利用补丁破解" class="headerlink" title="利用补丁破解"></a>利用补丁破解</h3><p>安装完成后安全起见先不要打开ps，我们先下载补丁工具。<br>下载链接：<a href="https://pan.baidu.com/s/1RWVV7HKcgqNU_a6GsLjyDw" target="_blank" rel="noopener">网盘链接</a> <a href="/uploads/downloadPS/PhotoshopCC2019pjbd_48343.zip">其他链接</a></p><p>将压缩包里的adobe.photoshop.cc.2019.20.0.0-patch.exe文件解压到ps安装目录下，就是你刚才修改的安装位置，保证那个位置下有photoshop.exe文件。</p><p>然后点击运行补丁（你可能会听到一段诡异的音乐。。。）。</p><img width="50%" data-src="/uploads/downloadPS/6.PNG"><p>点击应用，等待出现文件补丁已成功完成的提示。</p><img width="50%" data-src="/uploads/downloadPS/7.PNG"><p>这样就破解完成了，这时再打开ps发现没有试用还有多少天的提醒了。</p><img width="50%" data-src="/uploads/downloadPS/8.PNG"><p>按照补丁制作者的建议，在 编辑 ==&gt; 首选项 ==&gt; 常规 ==&gt; 停用”主页”屏幕 打钩。</p><img width="50%" data-src="/uploads/downloadPS/9.PNG"><p>最后做好重启一下ps再试用。</p><p>注：这篇文章是我安装后就写了，我在安装完的七天后再次检验是否失效，如果失效我会更新补丁，如果补丁失效可以回来看我是否有更新方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Photoshop如今已经非常常用的处理图片的软件，本文就是介绍一下photoshop cc 2019安装破解的完整过程。&lt;/p&gt;
&lt;p&gt;注：本文参考了&lt;a href=&quot;http://www.3322.cc/soft/48343.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.3322.cc/soft/48343.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="photoshop" scheme="https://zinw623.github.io/categories/photoshop/"/>
    
    
      <category term="破解" scheme="https://zinw623.github.io/tags/%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="photoshop" scheme="https://zinw623.github.io/tags/photoshop/"/>
    
  </entry>
  
  <entry>
    <title>Xshell：在本地浏览器使用服务器的jupyter notebook</title>
    <link href="https://zinw623.github.io/2019/08/02/hexo-jupyter/"/>
    <id>https://zinw623.github.io/2019/08/02/hexo-jupyter/</id>
    <published>2019-08-02T01:47:42.000Z</published>
    <updated>2019-08-04T03:19:26.760Z</updated>
    
    <content type="html"><![CDATA[<p>有的服务器里只是命令行，无法可视化，可能就无法使用jupyter notebook。其实需要稍微修改一下连接的属性就能在本地浏览器里打开在服务器里启动的jupyter notebook<a id="more"></a>，具体操作如下：</p><ol><li>首先右击会话管理器里的服务器标签，在菜单点击属性。</li></ol><img width="50%" data-src="/uploads/xshellJupyter/1.PNG"><ol start="2"><li>然后点击左侧的隧道，然后再点击添加。</li></ol><img width="50%" data-src="/uploads/xshellJupyter/2.PNG"><ol start="3"><li>输入两个端口号，我这输入的是jupyter notebook默认的8888端口，然后点确定</li></ol><img width="50%" data-src="/uploads/xshellJupyter/3.PNG"><ol start="4"><li>然后再取消右下方转发X11连接到的选项，然后点确定。</li></ol><img width="50%" data-src="/uploads/xshellJupyter/4.PNG"><ol start="5"><li>之后双击会话管理器里的服务器进行连接，在命令行里输入jupyter notebook，启动后在浏览器里访问<a href="http://localhost:8888/" target="_blank" rel="noopener"></a>就会看到jupyter notebook的界面了。</li></ol><img width="50%" data-src="/uploads/xshellJupyter/5.PNG">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有的服务器里只是命令行，无法可视化，可能就无法使用jupyter notebook。其实需要稍微修改一下连接的属性就能在本地浏览器里打开在服务器里启动的jupyter notebook
    
    </summary>
    
      <category term="Xshell" scheme="https://zinw623.github.io/categories/Xshell/"/>
    
    
      <category term="Xshell" scheme="https://zinw623.github.io/tags/Xshell/"/>
    
      <category term="jupyter notebook" scheme="https://zinw623.github.io/tags/jupyter-notebook/"/>
    
  </entry>
  
  <entry>
    <title>windows系统：Xshell下载安装+连接服务器</title>
    <link href="https://zinw623.github.io/2019/08/01/XshellDownload/"/>
    <id>https://zinw623.github.io/2019/08/01/XshellDownload/</id>
    <published>2019-08-01T04:32:52.000Z</published>
    <updated>2019-08-04T03:20:07.357Z</updated>
    
    <content type="html"><![CDATA[<p>学习深度学习需要足够的计算资源，往往需要连接远程服务器用来计算。本篇文章就介绍一下如何在windows系统里利用xshell连接服务器。</p><a id="more"></a><h3 id="xshell下载安装"><a href="#xshell下载安装" class="headerlink" title="xshell下载安装"></a>xshell下载安装</h3><p>首先要下载安装包:<a href="https://pan.baidu.com/s/1BK70moXvCw5xt3w7pKFH5g" target="_blank" rel="noopener">百度网盘资源</a>。<br>当然也可以去官网下载安装包，选择<a href="https://www.netsarang.com/zh/free-for-home-school/" target="_blank" rel="noopener">家庭学校免费版</a>，下载前要填一下姓名邮箱，提交后你会收到带有下载链接的邮件。</p><img width="50%" data-src="/uploads/downloadXshell/1.PNG"><p>点击安装包，然后一路默认下一步就ok。如果不想安装在c盘也可以，在其他盘里专门存xshell的各种文件，安装过程中只需把主文件夹换成你刚才的文件夹就ok。</p><img width="50%" data-src="/uploads/downloadXshell/2.PNG"><img width="50%" data-src="/uploads/downloadXshell/3.PNG"><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><ol><li><p>打开xshell后，点击左上角的文件然后点新建。</p><img width="50%" data-src="/uploads/downloadXshell/4.PNG"></li></ol><ol start="2"><li><p>然后填入服务器名称、主机、端口号,然后点确定。</p><img width="50%" data-src="/uploads/downloadXshell/5.png"></li><li><p>双击左侧会话管理器里刚建的服务器，在弹出的窗口里填入登录用的用户名，选上记住用户名。</p><img width="50%" data-src="/uploads/downloadXshell/6.PNG"></li><li><p>然后输入密码，并选上记住密码。</p><img width="50%" data-src="/uploads/downloadXshell/7.PNG"></li><li><p>点击确定以后就能在黑色的shell看到已经登录成功的提示了，然后就可以在shell里进行操作了。</p><img width="50%" data-src="/uploads/downloadXshell/8.PNG"></li><li><p>之后登录只需要双击左侧会话管理器里的对应标签即可。</p><h3 id="上传下载文件"><a href="#上传下载文件" class="headerlink" title="上传下载文件"></a>上传下载文件</h3></li><li><p>在Linux主机上，安装上传下载工具包rz及sz，使用sudo apt install lrzsz  进行安装。</p></li><li><p>从Windows上传文件，上传命令为rz；输入命令后会弹出选择要上传的本地文件的窗口。</p></li></ol><img width="50%" data-src="/uploads/downloadXshell/9.PNG"><ol start="3"><li><p>从Linux主机下载文件，下载命令为sz ，后面跟要下载的文件名。例如：</p><p> <code>sz helloworld.py。</code></p></li></ol><p>然后就会弹出选择要保存到本机位置的窗口。</p><img width="50%" data-src="/uploads/downloadXshell/10.PNG"><p><strong>xshell的基本操作就说这些了，这些的操作已经基本够用了</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习深度学习需要足够的计算资源，往往需要连接远程服务器用来计算。本篇文章就介绍一下如何在windows系统里利用xshell连接服务器。&lt;/p&gt;
    
    </summary>
    
      <category term="Xshell" scheme="https://zinw623.github.io/categories/Xshell/"/>
    
    
      <category term="Xshell" scheme="https://zinw623.github.io/tags/Xshell/"/>
    
      <category term="linux服务器" scheme="https://zinw623.github.io/tags/linux%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="windows" scheme="https://zinw623.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>人生</title>
    <link href="https://zinw623.github.io/2019/07/30/myFirstArticle/"/>
    <id>https://zinw623.github.io/2019/07/30/myFirstArticle/</id>
    <published>2019-07-30T03:18:40.000Z</published>
    <updated>2019-08-04T03:19:37.837Z</updated>
    
    <content type="html"><![CDATA[<p>一段旅程从2000年开始……</p><p>到我写这段话已经过了十九年······</p><p><strong>什么样的旅程呢？ 当然是创造的伟大旅程！！！</strong></p><a id="more"></a><p>还记得小时候自己喜欢借用自己手边的东西组成各种奇形怪状的玩具、凭着各种感性认识在各种课本上画着各种有趣插画、反复读着被老师夸过的自己认真写过的作文、努力地独立想出解决卷子上颇具难度的问题的方法。。。。。。</p><p>各种自己花时间用心搞过的创造总是能给自己足够的乐趣与成就感，并且这种凝结着努力和价值的东西也诠释着存在的意义。每个人的人生其实都可以通过以时间为索引的一个自己参与过的值得叙述给别人的事件的列表总结，就像这样：</p><p>“老子（老娘）年轻的时候，一个人······，可是到了中年，我来到了······，经历了我这一辈子不会忘记的事······，后来我老了，我打算去······，并且真的这么做了，一直想这样生活到现在······”</p><p>如何总结自己的一生？我想，不论是你拥有多少名利，得过多少荣誉，经历过多少难忘的事，这些可以被看作我们活着我们的行为创造过的各种沧桑岁月啊！我们投入过感情去创造的那些被自己认可的、有资格拿出来吹牛的经历将会成为我们一生的精炼内核。</p><p>所以我想：</p><blockquote><p>我是人，我有自我的意识，我要自由地用自己真实感情驱使着不太完美的躯壳去创造出完美的生命光辉，光辉不必夺目，但我年老回头看时能使我不自主地淡淡微笑，最好是能像夕阳落山前发出的光芒一样，并不强烈刺眼，但非常美丽，也曾与讨厌的黑夜争过地盘，也曾点燃过那无边的海面······</p></blockquote><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> people <span class="keyword">import</span> me</span><br><span class="line"></span><br><span class="line">real_lives = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> knowledge <span class="keyword">in</span> [<span class="string">'math'</span>, <span class="string">'deeplearning'</span>, <span class="string">'python'</span>, ...]:</span><br><span class="line"></span><br><span class="line">    me.learn(knowledge)</span><br><span class="line">    real_lives.apend(me.create())</span><br><span class="line"></span><br><span class="line">    me.lives -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>—感谢阅读—</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一段旅程从2000年开始……&lt;/p&gt;
&lt;p&gt;到我写这段话已经过了十九年······&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么样的旅程呢？ 当然是创造的伟大旅程！！！&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="一段话" scheme="https://zinw623.github.io/categories/%E4%B8%80%E6%AE%B5%E8%AF%9D/"/>
    
    
      <category term="人生" scheme="https://zinw623.github.io/tags/%E4%BA%BA%E7%94%9F/"/>
    
      <category term="创造" scheme="https://zinw623.github.io/tags/%E5%88%9B%E9%80%A0/"/>
    
  </entry>
  
</feed>
